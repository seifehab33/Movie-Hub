{"ast":null,"code":"var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n  this.errors = new Errors();\n  this.errorCount = 0;\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\nValidator.prototype = {\n  constructor: Validator,\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n    return this.errorCount === 0;\n  },\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n    passes = passes || function () {};\n    fails = fails || function () {};\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n    for (var attribute in rules) {\n      var rulesArray = rules[attribute];\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n    return parsedRules;\n  },\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n    var propertyValue = this._objectPath(this.input, parentPath);\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n      attributeRules.push(rule);\n    }\n    parsedRules[attribute] = attributeRules;\n  },\n  _replaceWildCards: function (path, nums) {\n    if (!nums) {\n      return path;\n    }\n    var path2 = path;\n    nums.forEach(function (value) {\n      if (Array.isArray(path2)) {\n        path2 = path2[0];\n      }\n      const pos = path2.indexOf('*');\n      if (pos === -1) {\n        return path2;\n      }\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n    if (Array.isArray(path)) {\n      path[0] = path2;\n      path2 = path;\n    }\n    return path2;\n  },\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n    this.messages._setCustom(customMessages);\n  },\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n    return rules;\n  },\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n      ruleArray;\n    rule.name = ruleString;\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n    return rule;\n  },\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n    return this.getRule('required').validate(value);\n  },\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n    return true;\n  },\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n    return !this.check();\n  },\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n    return this.hasAsync || hasCallback;\n  }\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerMissedRuleValidator = function (fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\nmodule.exports = Validator;","map":{"version":3,"names":["Rules","require","Lang","Errors","Attributes","AsyncResolvers","Validator","input","rules","customMessages","lang","getDefaultLang","messages","_make","_setCustom","setAttributeFormatter","prototype","attributeFormatter","errors","errorCount","hasAsync","_parseRules","constructor","numericRules","formatter","check","self","attribute","attributeRules","inputValue","_objectPath","_hasRule","_suppliedWithData","i","len","length","rule","ruleOptions","rulePassed","getRule","name","_isValidatable","validate","value","_addFailure","_shouldStopValidating","checkAsync","passes","fails","_this","failsOne","message","resolvedAll","allPassed","asyncResolvers","validateRule","resolverIndex","add","resolve","enableFiring","fire","msg","render","_flattenObject","obj","flattened","recurse","current","property","Object","getOwnPropertyNames","Array","isArray","isEmpty","p","path","hasOwnProperty","call","keys","replace","split","copy","attr","l","parsedRules","rulesArray","_parseRulesCheck","wildCardValues","indexOf","_parsedRulesRecurse","_parseRulesDefault","parentPath","substr","propertyValue","propertyNumber","workingValues","slice","push","_prepareRulesArray","_extractRuleAndRuleValue","_replaceWildCards","_replaceWildCardsMessages","isAsync","nums","path2","forEach","pos","key","newKey","ruleString","ruleArray","join","findRules","_hasNumericRule","isImplicit","stopOnAttributes","setAttributeNames","attributes","_setAttributeNames","func","_setAttributeFormatter","make","stopOnError","async","_checkAsync","funcName","callback","hasCallback","setMessages","_set","getMessages","_get","useLang","register","fn","fnReplacement","_setRuleMessage","registerImplicit","registerAsync","registerAsyncImplicit","registerMissedRuleValidator","module","exports"],"sources":["D:/Web Development/React-djangoproject/frontend/node_modules/validatorjs/src/validator.js"],"sourcesContent":["var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\n\nvar Validator = function (input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input || {};\n\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n\n  this.errors = new Errors();\n  this.errorCount = 0;\n\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function () {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function (passes, fails) {\n    var _this = this;\n    passes = passes || function () {};\n    fails = fails || function () {};\n\n    var failsOne = function (rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function (allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function (inputValue, ruleOptions, attribute, rule) {\n      return function () {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function () {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function (rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n\n    function recurse(current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + '.' + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '').split('.');\n    var copy = {};\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (typeof copy === 'object' && copy !== null && Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function (rules) {\n\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n\n    for (var attribute in rules) {\n\n      var rulesArray = rules[attribute];\n\n      this._parseRulesCheck(attribute, rulesArray, parsedRules);\n    }\n    return parsedRules;\n\n\n  },\n\n  _parseRulesCheck: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    if (attribute.indexOf('*') > -1) {\n      this._parsedRulesRecurse(attribute, rulesArray, parsedRules, wildCardValues);\n    } else {\n      this._parseRulesDefault(attribute, rulesArray, parsedRules, wildCardValues);\n    }\n  },\n\n  _parsedRulesRecurse: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var parentPath = attribute.substr(0, attribute.indexOf('*') - 1);\n    var propertyValue = this._objectPath(this.input, parentPath);\n\n    if (propertyValue) {\n      for (var propertyNumber = 0; propertyNumber < propertyValue.length; propertyNumber++) {\n        var workingValues = wildCardValues ? wildCardValues.slice() : [];\n        workingValues.push(propertyNumber);\n        this._parseRulesCheck(attribute.replace('*', propertyNumber), rulesArray, parsedRules, workingValues);\n      }\n    }\n  },\n\n  _parseRulesDefault: function (attribute, rulesArray, parsedRules, wildCardValues) {\n    var attributeRules = [];\n\n    if (rulesArray instanceof Array) {\n      rulesArray = this._prepareRulesArray(rulesArray);\n    }\n\n    if (typeof rulesArray === 'string') {\n      rulesArray = rulesArray.split('|');\n    }\n\n    for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n      rule = typeof rulesArray[i] === 'string' ? this._extractRuleAndRuleValue(rulesArray[i]) : rulesArray[i];\n      if (rule.value) {\n        rule.value = this._replaceWildCards(rule.value, wildCardValues);\n        this._replaceWildCardsMessages(wildCardValues);\n      }\n\n      if (Rules.isAsync(rule.name)) {\n        this.hasAsync = true;\n      }\n      attributeRules.push(rule);\n    }\n\n    parsedRules[attribute] = attributeRules;\n  },\n\n  _replaceWildCards: function (path, nums) {\n\n    if (!nums) {\n      return path;\n    }\n\n    var path2 = path;\n    nums.forEach(function (value) {\n      if(Array.isArray(path2)){\n        path2 = path2[0];\n      }\n      const pos = path2.indexOf('*');\n      if (pos === -1) {\n        return path2;\n      }\n      path2 = path2.substr(0, pos) + value + path2.substr(pos + 1);\n    });\n    if(Array.isArray(path)){\n      path[0] = path2;\n      path2 = path;\n    }\n    return path2;\n  },\n\n  _replaceWildCardsMessages: function (nums) {\n    var customMessages = this.messages.customMessages;\n    var self = this;\n    Object.keys(customMessages).forEach(function (key) {\n      if (nums) {\n        var newKey = self._replaceWildCards(key, nums);\n        customMessages[newKey] = customMessages[key];\n      }\n    });\n\n    this.messages._setCustom(customMessages);\n  },\n  /**\n   * Prepare rules if it comes in Array. Check for objects. Need for type validation.\n   *\n   * @param  {array} rulesArray\n   * @return {array}\n   */\n  _prepareRulesArray: function (rulesArray) {\n    var rules = [];\n\n    for (var i = 0, len = rulesArray.length; i < len; i++) {\n      if (typeof rulesArray[i] === 'object') {\n        for (var rule in rulesArray[i]) {\n          rules.push({\n            name: rule,\n            value: rulesArray[i][rule]\n          });\n        }\n      } else {\n        rules.push(rulesArray[i]);\n      }\n    }\n\n    return rules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function (attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function (ruleString) {\n    var rule = {},\n      ruleArray;\n\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(':');\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function (attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function (attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function (rule, value) {\n    if (Array.isArray(value)) {\n      return true;\n    }\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function (attribute, rulePassed) {\n\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function (attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function (func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function (name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function (attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function (passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function (fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function () {}, fails);\n    }\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function (funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function (lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function (lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function (lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function () {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function (func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function (attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @param  {function} fnReplacement\n * @return {void}\n */\nValidator.registerImplicit = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function (name, fn, message, fnReplacement) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsyncImplicit = function (name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsyncImplicit(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register validator for missed validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerMissedRuleValidator = function(fn, message) {\n  Rules.registerMissedRuleValidator(fn, message);\n};\n\nmodule.exports = Validator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}